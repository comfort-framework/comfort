<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestCoverageLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">comfort</a> &gt; <a href="index.source.html" class="el_package">de.ugoe.cs.comfort.collection.loader</a> &gt; <span class="el_source">TestCoverageLoader.java</span></div><h1>TestCoverageLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 University of Goettingen, Germany
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.ugoe.cs.comfort.collection.loader;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.ObjectMapper;
import de.ugoe.cs.comfort.FileNameUtils;
import de.ugoe.cs.comfort.Utils;
import de.ugoe.cs.comfort.annotations.SupportsJava;
import de.ugoe.cs.comfort.annotations.SupportsPython;
import de.ugoe.cs.comfort.collection.loader.testcoverage.ExecutionDataVisitor;
import de.ugoe.cs.comfort.collection.loader.testcoverage.JacocoReportReader;
import de.ugoe.cs.comfort.configuration.GeneralConfiguration;
import de.ugoe.cs.comfort.configuration.LoaderConfiguration;
import de.ugoe.cs.comfort.data.CoverageData;
import de.ugoe.cs.comfort.data.models.IUnit;
import de.ugoe.cs.comfort.data.models.JavaMethod;
import de.ugoe.cs.comfort.data.models.PythonCoverageLoaderTestMethod;
import de.ugoe.cs.comfort.data.models.PythonCoveragerloaderTestedMethod;
import de.ugoe.cs.comfort.data.models.PythonMethod;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.apache.bcel.generic.Type;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IClassCoverage;
import org.jacoco.core.analysis.ICounter;
import org.jacoco.core.analysis.ILine;
import org.jacoco.core.analysis.IMethodCoverage;
import org.jacoco.core.data.ExecutionDataStore;
import org.jacoco.report.JavaNames;

/**
 * @author Fabian Trautsch
 */
public class TestCoverageLoader extends BaseLoader {
<span class="fc" id="L61">    private static final JavaNames JN = new JavaNames();</span>
    private FileNameUtils fileNameUtils;

    public TestCoverageLoader(GeneralConfiguration generalConfiguration, LoaderConfiguration loaderConfiguration) {
<span class="fc" id="L65">        super(generalConfiguration, loaderConfiguration);</span>
<span class="fc" id="L66">        fileNameUtils = new FileNameUtils(generalConfiguration);</span>
<span class="fc" id="L67">    }</span>


    @SupportsPython
    public CoverageData loadPythonCoverageData() throws IOException {
<span class="fc" id="L72">        CoverageData covfefe = new CoverageData();</span>

<span class="fc" id="L74">        JsonParser jp = new JsonFactory().createParser(loaderConf.getCoverageLocation().toFile());</span>
<span class="fc" id="L75">        ObjectMapper mapper = new ObjectMapper();</span>

<span class="fc" id="L77">        jp.nextToken(); // START_ARRAY</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        while (jp.nextToken() != JsonToken.END_ARRAY) {</span>
            // Read PythonTest from JSON Coverage
<span class="fc" id="L80">            PythonCoverageLoaderTestMethod testMethod = mapper.readValue(jp, PythonCoverageLoaderTestMethod.class);</span>

            // Convert
<span class="fc" id="L83">            PythonMethod pythonMethod = null;</span>

            // Compatibility with files that do not have the location inside
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">            if(testMethod.getLocation() != null</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                    &amp;&amp; testMethod.getLocation().startsWith(generalConf.getProjectDir().toString())) {</span>
<span class="nc" id="L88">                String location = testMethod.getLocation()</span>
<span class="nc" id="L89">                        .replace(generalConf.getProjectDir().toString()+&quot;/&quot;, &quot;&quot;);</span>
<span class="nc" id="L90">                pythonMethod = new PythonMethod(testMethod, Paths.get(location));</span>
<span class="nc" id="L91">            } else {</span>
<span class="fc" id="L92">                pythonMethod = new PythonMethod(testMethod,</span>
<span class="fc" id="L93">                        fileNameUtils.getPathForPythonModuleFQN(testMethod.getModule()));</span>
            }

<span class="fc" id="L96">            Set&lt;IUnit&gt; testedMethodsWithoutTestsItself = new HashSet&lt;&gt;();</span>

            // We need to check all tested methods, if there is a test itself is in it
            // This can be the case if the tests are part of the program itself (e.g. networkx/util/tests)
<span class="fc bfc" id="L100" title="All 2 branches covered.">            for(PythonCoveragerloaderTestedMethod testedMethod: testMethod.getTestedMethods()) {</span>
                // Convert
<span class="fc" id="L102">                PythonMethod pythonTestedMethod = null;</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">                if(testedMethod.getLocation().startsWith(generalConf.getProjectDir().toString())) {</span>
<span class="nc" id="L104">                    String location = testedMethod.getLocation()</span>
<span class="nc" id="L105">                            .replace(generalConf.getProjectDir().toString()+&quot;/&quot;, &quot;&quot;);</span>
<span class="nc" id="L106">                    pythonTestedMethod = new PythonMethod(testedMethod, Paths.get(location));</span>
<span class="nc" id="L107">                } else {</span>
<span class="fc" id="L108">                    pythonTestedMethod = new PythonMethod(testedMethod,</span>
<span class="fc" id="L109">                            fileNameUtils.getPathForPythonModuleFQN(testedMethod.getModule()));</span>
                }
<span class="fc" id="L111">                pythonTestedMethod.setCoveredLines(testedMethod.getCoveredLines());</span>

<span class="fc" id="L113">                testedMethodsWithoutTestsItself.add(pythonTestedMethod);</span>
<span class="fc" id="L114">            }</span>
<span class="fc" id="L115">            covfefe.add(pythonMethod, testedMethodsWithoutTestsItself);</span>
<span class="fc" id="L116">            logger.debug(&quot;Found {} which tests {}&quot;, pythonMethod, testedMethodsWithoutTestsItself);</span>
<span class="fc" id="L117">        }</span>
<span class="fc" id="L118">        return covfefe;</span>
    }


    @SupportsJava
    public CoverageData loadJavaCoverageData() throws IOException {
        // Get jacoco reader and visitor for the execution data
<span class="fc" id="L125">        JacocoReportReader reader = new JacocoReportReader(loaderConf.getCoverageLocation().toFile());</span>
<span class="fc" id="L126">        ExecutionDataVisitor visitor = new ExecutionDataVisitor();</span>

        // Read the jacoco execution report
<span class="fc" id="L129">        reader.readJacocoReport(visitor, visitor);</span>

        // Create coverage data
<span class="fc" id="L132">        CoverageData covData = new CoverageData();</span>

<span class="fc" id="L134">        final ExecutorService executor = Executors.newFixedThreadPool(generalConf.getNThreads());</span>
<span class="fc" id="L135">        CountDownLatch latch = new CountDownLatch(visitor.getSessions().entrySet().size());</span>

        // Go through each session and parse the data. Only include sessions that have a name
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for(Map.Entry&lt;String, ExecutionDataStore&gt; entry: visitor.getSessions().entrySet()) {</span>
<span class="fc" id="L139">            executor.submit(() -&gt; {</span>
                try {
<span class="fc" id="L141">                    String sessionId = entry.getKey();</span>

                    // If it does not have a session id, we do not know which test was executed
<span class="pc bpc" id="L144" title="1 of 4 branches missed.">                    if(!sessionId.isEmpty() &amp;&amp; sessionId.contains(&quot;%%&quot;)) {</span>
<span class="fc" id="L145">                        logger.info(&quot;Analyzing Session {}...&quot;, entry.getKey());</span>

                        // Create test class &amp; method
<span class="fc" id="L148">                        String fqnOfTest = sessionId.split(&quot;%%&quot;)[0];</span>
<span class="fc" id="L149">                        String methodName = sessionId.split(&quot;%%&quot;)[1];</span>
<span class="fc" id="L150">                        logger.debug(&quot;Created the following TestMethod: {}&quot;, fqnOfTest+&quot;.&quot;+methodName);</span>


                        // Read the execution data
<span class="fc" id="L154">                        ExecutionDataStore data = entry.getValue();</span>

                        // Analyze the files, where all class files in the project dir are looked at

<span class="fc" id="L158">                        CoverageBuilder covfefe = reader.analyzeFiles(data, Utils.getAllFilesFromProjectForRegex(</span>
<span class="fc" id="L159">                                generalConf.getProjectDir(), &quot;.*\\.class&quot;));</span>

                        // Parse the class coverage data
<span class="fc" id="L162">                        Set&lt;IUnit&gt; testedMethods = parseClassCoverageDataForJavaTestMethod(fqnOfTest, covfefe);</span>
<span class="fc" id="L163">                        IUnit testMethod = new JavaMethod(fqnOfTest, methodName, new ArrayList&lt;&gt;(),</span>
<span class="fc" id="L164">                                fileNameUtils.getPathForJavaClassFQN(fqnOfTest));</span>

<span class="fc" id="L166">                        covData.add(testMethod, testedMethods);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                        if(testedMethods.size() == 0) {</span>
<span class="nc" id="L168">                            logger.warn(&quot;Could not find tested methods!&quot;);</span>
                        }


                    }
<span class="nc" id="L173">                } catch (IOException e) {</span>
<span class="nc" id="L174">                    logger.catching(e);</span>
                } finally {
<span class="pc" id="L176">                    latch.countDown();</span>
<span class="pc" id="L177">                }</span>

<span class="fc" id="L179">            });</span>
<span class="fc" id="L180">        }</span>


        try {
<span class="fc" id="L184">            latch.await();</span>
<span class="nc" id="L185">        } catch (InterruptedException e) {</span>
<span class="nc" id="L186">            logger.catching(e);</span>
        } finally {
<span class="pc" id="L188">            executor.shutdown();</span>
<span class="pc" id="L189">        }</span>
<span class="fc" id="L190">        return covData;</span>
    }

    private Set&lt;IUnit&gt; parseClassCoverageDataForJavaTestMethod(String fqnOfTest, CoverageBuilder covfefe) {
        // Go through all classes that were found and have a look if it is covered
<span class="fc" id="L195">        Set&lt;IUnit&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for(IClassCoverage classCoverage: covfefe.getClasses()) {</span>
<span class="fc" id="L197">            String className = JN.getQualifiedClassName(classCoverage.getName());</span>
            // If it is covered: go through its methods to see which methods are covered
            // Exclude the test method itself and if the class is a test class
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if(classCoverage.getClassCounter().getCoveredCount() == 1) {</span>
<span class="fc" id="L201">                result.addAll(parseMethodCoverageDataForJavaTestMethod(classCoverage));</span>
            }
<span class="fc" id="L203">        }</span>

<span class="fc" id="L205">        return result;</span>
    }

    private Set&lt;JavaMethod&gt; parseMethodCoverageDataForJavaTestMethod(IClassCoverage classCoverage) {
<span class="fc" id="L209">        Set&lt;JavaMethod&gt; allTestedMethods = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for(IMethodCoverage methodCoverage: classCoverage.getMethods()) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if(methodCoverage.getMethodCounter().getCoveredCount() == 1) {</span>
<span class="fc" id="L212">                String packageName = classCoverage.getPackageName().replace(&quot;/&quot;, &quot;.&quot;);</span>
<span class="fc" id="L213">                String className = classCoverage.getName().replace(classCoverage.getPackageName()+&quot;/&quot;, &quot;&quot;);</span>

                // Add parameter
<span class="fc" id="L216">                List&lt;String&gt; parameter = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                for(Type type : Type.getArgumentTypes(methodCoverage.getDesc())) {</span>
<span class="fc" id="L218">                    parameter.add(type.toString());</span>
                }

                // Create Java Method for tested method
                JavaMethod testedJavaMethod;
                try {
<span class="fc" id="L224">                    testedJavaMethod = new JavaMethod(packageName, className, methodCoverage.getName(), parameter,</span>
<span class="fc" id="L225">                            fileNameUtils.getPathForJavaClassFQN(packageName+&quot;.&quot;+className));</span>
<span class="nc" id="L226">                } catch (FileNotFoundException e) {</span>
<span class="nc" id="L227">                    testedJavaMethod = new JavaMethod(packageName, className, methodCoverage.getName(), parameter,</span>
                            null);
<span class="nc" id="L229">                    logger.warn(&quot;Could not find file for class {}&quot;, packageName+&quot;.&quot;+className);</span>
<span class="fc" id="L230">                }</span>

                // Calculate covered lines
<span class="fc" id="L233">                Integer coveredLines = coveredLines(methodCoverage);</span>
<span class="fc" id="L234">                testedJavaMethod.setCoveredLines(coveredLines);</span>
<span class="fc" id="L235">                logger.debug(&quot;Covered unit: {}&quot;, testedJavaMethod.getFQN());</span>

                // Add to result set
<span class="fc" id="L238">                allTestedMethods.add(testedJavaMethod);</span>
            }
<span class="fc" id="L240">        }</span>

<span class="fc" id="L242">        return allTestedMethods;</span>
    }


    private static Integer coveredLines(IMethodCoverage coverage) {
<span class="fc" id="L247">        Integer allCoveredLines = 0;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (int lineId = coverage.getFirstLine(); lineId &lt;= coverage.getLastLine(); lineId++) {</span>
<span class="fc" id="L249">            ILine line = coverage.getLine(lineId);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            switch (line.getInstructionCounter().getStatus()) {</span>
                case ICounter.FULLY_COVERED:
                case ICounter.PARTLY_COVERED:
<span class="fc" id="L253">                    allCoveredLines++;</span>
<span class="fc" id="L254">                    break;</span>
                default:
            }
        }
<span class="fc" id="L258">        return allCoveredLines;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>