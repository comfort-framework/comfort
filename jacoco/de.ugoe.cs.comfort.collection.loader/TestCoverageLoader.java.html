<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestCoverageLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">comfort</a> &gt; <a href="index.source.html" class="el_package">de.ugoe.cs.comfort.collection.loader</a> &gt; <span class="el_source">TestCoverageLoader.java</span></div><h1>TestCoverageLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 University of Goettingen, Germany
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.ugoe.cs.comfort.collection.loader;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.ObjectMapper;
import de.ugoe.cs.comfort.FileNameUtils;
import de.ugoe.cs.comfort.Utils;
import de.ugoe.cs.comfort.annotations.SupportsJava;
import de.ugoe.cs.comfort.annotations.SupportsPython;
import de.ugoe.cs.comfort.collection.loader.testcoverage.ExecutionDataVisitor;
import de.ugoe.cs.comfort.collection.loader.testcoverage.JacocoReportReader;
import de.ugoe.cs.comfort.configuration.GeneralConfiguration;
import de.ugoe.cs.comfort.configuration.LoaderConfiguration;
import de.ugoe.cs.comfort.data.CoverageData;
import de.ugoe.cs.comfort.data.models.IUnit;
import de.ugoe.cs.comfort.data.models.JavaMethod;
import de.ugoe.cs.comfort.data.models.PythonCoverageLoaderTestMethod;
import de.ugoe.cs.comfort.data.models.PythonCoveragerloaderTestedMethod;
import de.ugoe.cs.comfort.data.models.PythonMethod;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.apache.bcel.generic.Type;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IClassCoverage;
import org.jacoco.core.analysis.IMethodCoverage;
import org.jacoco.core.data.ExecutionDataStore;
import org.jacoco.report.JavaNames;

/**
 * @author Fabian Trautsch
 */
public class TestCoverageLoader extends BaseLoader {
<span class="fc" id="L58">    private static final JavaNames JN = new JavaNames();</span>
    private FileNameUtils fileNameUtils;

    public TestCoverageLoader(GeneralConfiguration generalConfiguration, LoaderConfiguration loaderConfiguration) {
<span class="fc" id="L62">        super(generalConfiguration, loaderConfiguration);</span>
<span class="fc" id="L63">        fileNameUtils = new FileNameUtils(generalConfiguration);</span>
<span class="fc" id="L64">    }</span>


    @SupportsPython
    public CoverageData loadPythonCoverageData() throws IOException {
<span class="fc" id="L69">        CoverageData covfefe = new CoverageData();</span>

<span class="fc" id="L71">        JsonParser jp = new JsonFactory().createParser(loaderConf.getCoverageLocation().toFile());</span>
<span class="fc" id="L72">        ObjectMapper mapper = new ObjectMapper();</span>

<span class="fc" id="L74">        jp.nextToken(); // START_ARRAY</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        while (jp.nextToken() != JsonToken.END_ARRAY) {</span>
            // Read PythonTest from JSON Coverage
<span class="fc" id="L77">            PythonCoverageLoaderTestMethod testMethod = mapper.readValue(jp, PythonCoverageLoaderTestMethod.class);</span>

            // Convert
<span class="fc" id="L80">            PythonMethod pythonMethod = new PythonMethod(testMethod,</span>
<span class="fc" id="L81">                    fileNameUtils.getPathForPythonModuleFQN(testMethod.getModule()));</span>

<span class="fc" id="L83">            Set&lt;IUnit&gt; testedMethodsWithoutTestsItself = new HashSet&lt;&gt;();</span>

            // We need to check all tested methods, if there is a test itself is in it
            // This can be the case if the tests are part of the program itself (e.g. networkx/util/tests)
<span class="fc bfc" id="L87" title="All 2 branches covered.">            for(PythonCoveragerloaderTestedMethod testedMethod: testMethod.getTestedMethods()) {</span>
                // Convert
<span class="fc" id="L89">                PythonMethod pythonTestedMethod = new PythonMethod(testedMethod,</span>
<span class="fc" id="L90">                        fileNameUtils.getPathForPythonModuleFQN(testedMethod.getModule()));</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">                if(pythonTestedMethod.isTestBasedOnMethod()) {</span>
<span class="fc" id="L93">                    logger.debug(&quot;Excluding test {}, because it is a test!&quot;, pythonTestedMethod);</span>
                } else {
<span class="fc" id="L95">                    testedMethodsWithoutTestsItself.add(pythonTestedMethod);</span>
                }
<span class="fc" id="L97">            }</span>
<span class="fc" id="L98">            covfefe.add(pythonMethod, testedMethodsWithoutTestsItself);</span>
<span class="fc" id="L99">        }</span>

<span class="fc" id="L101">        return covfefe;</span>
    }


    @SupportsJava
    public CoverageData loadJavaCoverageData() throws IOException {
        // Get jacoco reader and visitor for the execution data
<span class="fc" id="L108">        JacocoReportReader reader = new JacocoReportReader(loaderConf.getCoverageLocation().toFile());</span>
<span class="fc" id="L109">        ExecutionDataVisitor visitor = new ExecutionDataVisitor();</span>

        // Read the jacoco execution report
<span class="fc" id="L112">        reader.readJacocoReport(visitor, visitor);</span>

        // Create coverage data
<span class="fc" id="L115">        CoverageData covData = new CoverageData();</span>

<span class="fc" id="L117">        final ExecutorService executor = Executors.newFixedThreadPool(generalConf.getNThreads());</span>
<span class="fc" id="L118">        CountDownLatch latch = new CountDownLatch(visitor.getSessions().entrySet().size());</span>

        // Go through each session and parse the data. Only include sessions that have a name
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for(Map.Entry&lt;String, ExecutionDataStore&gt; entry: visitor.getSessions().entrySet()) {</span>
<span class="fc" id="L122">            executor.submit(() -&gt; {</span>
                try {
<span class="fc" id="L124">                    String sessionId = entry.getKey();</span>

                    // If it does not have a session id, we do not know which test was executed
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">                    if(!sessionId.isEmpty() &amp;&amp; sessionId.contains(&quot;%%&quot;)) {</span>
<span class="fc" id="L128">                        logger.info(&quot;Analyzing Session {}...&quot;, entry.getKey());</span>

                        // Create test class &amp; method
<span class="fc" id="L131">                        String fqnOfTest = sessionId.split(&quot;%%&quot;)[0];</span>
<span class="fc" id="L132">                        String methodName = sessionId.split(&quot;%%&quot;)[1];</span>
<span class="fc" id="L133">                        logger.debug(&quot;Created the following TestMethod: {}&quot;, fqnOfTest+&quot;.&quot;+methodName);</span>


                        // Read the execution data
<span class="fc" id="L137">                        ExecutionDataStore data = entry.getValue();</span>

                        // Analyze the files, where all class files in the project dir are looked at

<span class="fc" id="L141">                        CoverageBuilder covfefe = reader.analyzeFiles(data, Utils.getAllFilesFromProjectForRegex(</span>
<span class="fc" id="L142">                                generalConf.getProjectDir(), &quot;.*\\.class&quot;));</span>

                        // Parse the class coverage data
<span class="fc" id="L145">                        Set&lt;IUnit&gt; testedMethods = parseClassCoverageDataForJavaTestMethod(fqnOfTest, covfefe);</span>
<span class="fc" id="L146">                        IUnit testMethod = new JavaMethod(fqnOfTest, methodName, new ArrayList&lt;&gt;(),</span>
<span class="fc" id="L147">                                fileNameUtils.getPathForJavaClassFQN(fqnOfTest));</span>

<span class="fc" id="L149">                        covData.add(testMethod, testedMethods);</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                        if(testedMethods.size() == 0) {</span>
<span class="nc" id="L151">                            logger.warn(&quot;Could not find tested methods!&quot;);</span>
                        }


                    }
<span class="nc" id="L156">                } catch (IOException e) {</span>
<span class="nc" id="L157">                    logger.catching(e);</span>
                } finally {
<span class="pc" id="L159">                    latch.countDown();</span>
<span class="pc" id="L160">                }</span>

<span class="fc" id="L162">            });</span>
<span class="fc" id="L163">        }</span>


        try {
<span class="fc" id="L167">            latch.await();</span>
<span class="nc" id="L168">        } catch (InterruptedException e) {</span>
<span class="nc" id="L169">            logger.catching(e);</span>
        } finally {
<span class="pc" id="L171">            executor.shutdown();</span>
<span class="pc" id="L172">        }</span>
<span class="fc" id="L173">        return covData;</span>
    }

    private Set&lt;IUnit&gt; parseClassCoverageDataForJavaTestMethod(String fqnOfTest, CoverageBuilder covfefe) {
        // Go through all classes that were found and have a look if it is covered
<span class="fc" id="L178">        Set&lt;IUnit&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        for(IClassCoverage classCoverage: covfefe.getClasses()) {</span>
<span class="fc" id="L180">            String className = JN.getQualifiedClassName(classCoverage.getName());</span>
            // If it is covered: go through its methods to see which methods are covered
            // Exclude the test method itself and if the class is a test class
<span class="fc bfc" id="L183" title="All 4 branches covered.">            if(classCoverage.getClassCounter().getCoveredCount() == 1 &amp;&amp; !className.equals(fqnOfTest)</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">                    &amp;&amp; !Utils.isTestBasedOnFQN(className)) {</span>
<span class="fc" id="L185">                result.addAll(parseMethodCoverageDataForJavaTestMethod(classCoverage));</span>
            }
<span class="fc" id="L187">        }</span>

<span class="fc" id="L189">        return result;</span>
    }

    private Set&lt;JavaMethod&gt; parseMethodCoverageDataForJavaTestMethod(IClassCoverage classCoverage) {
<span class="fc" id="L193">        Set&lt;JavaMethod&gt; allTestedMethods = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for(IMethodCoverage methodCoverage: classCoverage.getMethods()) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if(methodCoverage.getMethodCounter().getCoveredCount() == 1) {</span>
                // Calculate covered and uncovered lines
                //Map&lt;String, List&lt;Integer&gt;&gt; lines = coveredLines(methodCoverage);


<span class="fc" id="L200">                String packageName = classCoverage.getPackageName().replace(&quot;/&quot;, &quot;.&quot;);</span>
<span class="fc" id="L201">                String className = classCoverage.getName().replace(classCoverage.getPackageName()+&quot;/&quot;, &quot;&quot;);</span>

                // Add parameter
<span class="fc" id="L204">                List&lt;String&gt; parameter = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                for(Type type : Type.getArgumentTypes(methodCoverage.getDesc())) {</span>
<span class="fc" id="L206">                    parameter.add(type.toString());</span>
                }

                // Create Java Method for tested method
                JavaMethod testedJavaMethod;
                try {
<span class="fc" id="L212">                    testedJavaMethod = new JavaMethod(packageName, className, methodCoverage.getName(), parameter,</span>
<span class="fc" id="L213">                            fileNameUtils.getPathForJavaClassFQN(packageName+&quot;.&quot;+className));</span>
<span class="nc" id="L214">                } catch (FileNotFoundException e) {</span>
<span class="nc" id="L215">                    testedJavaMethod = new JavaMethod(packageName, className, methodCoverage.getName(), parameter,</span>
                            null);
<span class="nc" id="L217">                    logger.warn(&quot;Could not find file for class {}&quot;, packageName+&quot;.&quot;+className);</span>
<span class="fc" id="L218">                }</span>
<span class="fc" id="L219">                logger.debug(&quot;Covered unit: {}&quot;, testedJavaMethod.getFQN());</span>

                // Add to result set
<span class="fc" id="L222">                allTestedMethods.add(testedJavaMethod);</span>
            }
<span class="fc" id="L224">        }</span>

<span class="fc" id="L226">        return allTestedMethods;</span>
    }

    /*
    private static Map&lt;String, List&lt;Integer&gt;&gt; coveredLines(IMethodCoverage coverage) {
        List&lt;Integer&gt; coveredLines = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; uncoveredLines = new ArrayList&lt;&gt;();
        for (int lineId = coverage.getFirstLine(); lineId &lt;= coverage.getLastLine(); lineId++) {
            ILine line = coverage.getLine(lineId);
            switch (line.getInstructionCounter().getStatus()) {
                case ICounter.FULLY_COVERED:
                case ICounter.PARTLY_COVERED:
                    coveredLines.add(lineId);
                    break;
                case ICounter.NOT_COVERED:
                    uncoveredLines.add(lineId);
                    break;
                default:
            }
        }

        Map&lt;String, List&lt;Integer&gt;&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;covered&quot;, coveredLines);
        result.put(&quot;uncovered&quot;, uncoveredLines);

        return result;
    }*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>